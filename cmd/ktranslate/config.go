package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"strconv"
	"strings"
	"text/template"
	"time"
)

// Code to generate a config file from flags.
func makeConfig() int {
	fs := []*flag.Flag{}
	flag.VisitAll(func(f *flag.Flag) {
		if f.Name != "v" && f.Name != "config" { // Skip basic ones.
			fs = append(fs, f)
		}
	})

	var buf bytes.Buffer
	err := tpl.Execute(&buf, struct {
		Flags []*flag.Flag
		Now   string
	}{fs, time.Now().String()})
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "template: %s\n", err)
		return 1
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "gofmt: %s\n", err)
		return 1
	}

	fmt.Print(string(src))
	return 0
}

var tpl = template.Must(template.New("").
	Option("missingkey=error").
	Funcs(template.FuncMap{
		"ucfirst": func(s string) string { return strings.ReplaceAll(strings.Title(s), ".", "") },
		"pad":     func(s string, l int) string { return s + strings.Repeat(" ", l-len(s)) },
		"quote":   func() string { return "`" },
		"getType": func(val flag.Value) string {
			vs := val.String()
			if vs == "true" || vs == "false" { // Get bool out of way.
				return "bool"
			}
			if _, err := strconv.Atoi(vs); err == nil { // If parses as int, its an int.
				return "int"
			}
			return "string" // Default to string.
		},
	}).
	Parse(`//go:generate sh -c "go run ../../cmd/ktranslate -log_level error config > ../../config.go && mv ../../config.go ../../pkg/kt/config.go"
// Code generated by ktranslate; DO NOT EDIT.

package kt

import (
  "flag"
)

// Main config type -- handles all the flags which are set.
type KTConf struct {
{{range $f := .Flags}}
    {{$f.Name|ucfirst}} string {{quote}}yaml:"{{$f.Name}}"{{quote}} // {{.Usage}}{{end}}
}

// Loads config and uses this to override any flags.
func ParseConfig(cfg KTConf) error {
{{range $f := .Flags}}
    if cfg.{{$f.Name|ucfirst}} != "" {
      flag.Set("{{$f.Name}}", cfg.{{$f.Name|ucfirst}})
    }{{end}}

	return nil
}

`))
