//go:generate sh -c "go run ../../cmd/ktranslate -log_level error config > ../../config.go && mv ../../config.go ../../pkg/kt/config.go"
// Code generated by ktranslate; DO NOT EDIT.

package kt

import (
	"flag"
)

// Main config type -- handles all the flags which are set.
type KTConf struct {
	Api_device_file         string `yaml:"api_device_file"`         // File to sideload devices without hitting API
	Api_devices             string `yaml:"api_devices"`             // json file containing dumy devices to use for the stub Kentik API
	Api_root                string `yaml:"api_root"`                // API url prefix. If not set, defaults to https://api.kentik.com
	Application_map         string `yaml:"application_map"`         // File containing custom application mappings
	Asn                     string `yaml:"asn"`                     // Asn mapping file
	Aws_lambda              string `yaml:"aws_lambda"`              // Run as a AWS Lambda function
	Aws_local_file          string `yaml:"aws_local_file"`          // If set, process this local file and exit
	Aws_regions             string `yaml:"aws_regions"`             // CSV list of region to run in. Will look for metadata in all regions, run SQS in first region.
	BootstrapServers        string `yaml:"bootstrap.servers"`       // bootstrap.servers
	Compression             string `yaml:"compression"`             // compression algo to use (none|gzip|snappy|deflate|null)
	Dns                     string `yaml:"dns"`                     // Resolve IPs at this ip:port
	Enricher                string `yaml:"enricher"`                // Send data to this http url for enrichment.
	File_flush_sec          string `yaml:"file_flush_sec"`          // Create a new output file every this many seconds
	File_on                 string `yaml:"file_on"`                 // If true, start writting to file sink right away. Otherwise, wait for a USR1 signal
	File_out                string `yaml:"file_out"`                // Write flows seen to log to this directory if set
	Filters                 string `yaml:"filters"`                 // Any filters to use. Format: type dimension operator value
	Flow_only               string `yaml:"flow_only"`               // If true, don't poll snmp devices.
	Format                  string `yaml:"format"`                  // Format to convert kflow to: (json|flat_json|avro|netflow|influx|carbon|prometheus|new_relic|new_relic_metric|splunk|elasticsearch|kflow)
	Format_rollup           string `yaml:"format_rollup"`           // Format to convert rollups to: (json|avro|netflow|influx|prometheus|new_relic|new_relic_metric|splunk|elasticsearch|kflow)
	Gcloud_bucket           string `yaml:"gcloud_bucket"`           // GCloud Storage Bucket to write flows to
	Gcloud_content_type     string `yaml:"gcloud_content_type"`     // GCloud Storage Content Type
	Gcloud_flush_sec        string `yaml:"gcloud_flush_sec"`        // Create a new output file every this many seconds
	Gcloud_prefix           string `yaml:"gcloud_prefix"`           // GCloud Storage object prefix
	GcpProject              string `yaml:"gcp.project"`             // Google ProjectID to listen for flows on
	GcpSample               string `yaml:"gcp.sample"`              // Sample rate of the vpc export (as defined in the VPC setup)
	GcpSub                  string `yaml:"gcp.sub"`                 // Google Sub to listen for flows on
	Gcp_pubsub_project_id   string `yaml:"gcp_pubsub_project_id"`   // GCP PubSub Project ID to use
	Gcp_pubsub_topic        string `yaml:"gcp_pubsub_topic"`        // GCP PubSub Topic to publish to
	Geo                     string `yaml:"geo"`                     // Geo mapping file
	HttpSource              string `yaml:"http.source"`             // Listen for content sent via http.
	Http_header             string `yaml:"http_header"`             // Any custom http headers to set on outbound requests
	Http_insecure           string `yaml:"http_insecure"`           // Allow insecure urls.
	Http_timeout_sec        string `yaml:"http_timeout_sec"`        // Timeout each request after this long.
	Http_url                string `yaml:"http_url"`                // URL to post to
	Iam_role                string `yaml:"iam_role"`                // IAM Role to use for processing flow
	Info_collector          string `yaml:"info_collector"`          // Also send stats about this collector
	Input_threads           string `yaml:"input_threads"`           // Number of threads to run for input processing
	Kafka_topic             string `yaml:"kafka_topic"`             // kafka topic to produce on
	Kentik_email            string `yaml:"kentik_email"`            // Kentik email to use for API calls
	Kentik_plan             string `yaml:"kentik_plan"`             // Kentik plan id to use for creating devices
	Kentik_relay_url        string `yaml:"kentik_relay_url"`        // If set, override the kentik api url to send flow over here.
	Listen                  string `yaml:"listen"`                  // IP:Port to listen on
	Log_level               string `yaml:"log_level"`               // Logging Level
	Mapping                 string `yaml:"mapping"`                 // Mapping file to use for enums
	Max_before_sample       string `yaml:"max_before_sample"`       // Only sample when a set of inputs is at least this many
	Max_flows_per_message   string `yaml:"max_flows_per_message"`   // Max number of flows to put in each emitted message
	Max_threads             string `yaml:"max_threads"`             // Dynamically grow threads up to this number
	Metalisten              string `yaml:"metalisten"`              // HTTP interface and port to bind on
	Metrics                 string `yaml:"metrics"`                 // Metrics Configuration. none|syslog|stderr|graphite:127.0.0.1:2003
	Net_protocol            string `yaml:"net_protocol"`            // Use this protocol for writing data (udp|tcp|unix)
	Net_server              string `yaml:"net_server"`              // Write flows seen to this address (host and port)
	Netflow_version         string `yaml:"netflow_version"`         // Version of netflow to produce: (netflow9|ipfix)
	NfAddr                  string `yaml:"nf.addr"`                 // Sflow/NetFlow/IPFIX listening address
	NfMapping               string `yaml:"nf.mapping"`              // Configuration file for custom netflow mappings
	NfMessageFields         string `yaml:"nf.message.fields"`       // The list of fields to include in flow messages. Can be any of Type,TimeReceived,SequenceNum,SamplingRate,SamplerAddress,TimeFlowStart,TimeFlowEnd,Bytes,Packets,SrcAddr,DstAddr,Etype,Proto,SrcPort,DstPort,InIf,OutIf,SrcMac,DstMac,SrcVlan,DstVlan,VlanId,IngressVrfID,EgressVrfID,IPTos,ForwardingStatus,IPTTL,TCPFlags,IcmpType,IcmpCode,IPv6FlowLabel,FragmentId,FragmentOffset,BiFlowDirection,SrcAS,DstAS,NextHop,NextHopAS,SrcNet,DstNet,HasMPLS,MPLSCount,MPLS1TTL,MPLS1Label,MPLS2TTL,MPLS2Label,MPLS3TTL,MPLS3Label,MPLSLastTTL,MPLSLastLabel,CustomInteger1,CustomInteger2,CustomInteger3,CustomInteger4,CustomInteger5,CustomBytes1,CustomBytes2,CustomBytes3,CustomBytes4,CustomBytes5
	NfPort                  string `yaml:"nf.port"`                 // Sflow/NetFlow/IPFIX listening port
	NfPromListen            string `yaml:"nf.prom.listen"`          // Run a promethues metrics collector here
	NfReuserport            string `yaml:"nf.reuserport"`           // Enable so_reuseport for Sflow/NetFlow/IPFIX
	NfSource                string `yaml:"nf.source"`               // Run NetFlow Ingest Directly. Valid values here are netflow5|netflow9|ipfix|sflow
	NfWorkers               string `yaml:"nf.workers"`              // Number of workers per flow collector
	Nr_account_id           string `yaml:"nr_account_id"`           // If set, sends flow to New Relic
	Nr_check_json           string `yaml:"nr_check_json"`           // Verify body is valid json before sending on
	Nr_estimate_only        string `yaml:"nr_estimate_only"`        // If true, record size of inputs to NR but don't actually send anything
	Nr_region               string `yaml:"nr_region"`               // NR Region to use. US|EU
	Olly_dataset            string `yaml:"olly_dataset"`            // Olly dataset name
	Olly_write_key          string `yaml:"olly_write_key"`          // Olly dataset name
	Prom_listen             string `yaml:"prom_listen"`             // Bind to listen for prometheus requests on.
	Prom_seen               string `yaml:"prom_seen"`               // Number of flows needed inbound before we start writting to the collector
	Rollup_and_alpha        string `yaml:"rollup_and_alpha"`        // Send both rollups and alpha inputs to sinks
	Rollup_interval         string `yaml:"rollup_interval"`         // Export timer for rollups in seconds
	Rollup_key_join         string `yaml:"rollup_key_join"`         // Token to use to join dimension keys together
	Rollup_top_k            string `yaml:"rollup_top_k"`            // Export only these top values
	Rollups                 string `yaml:"rollups"`                 // Any rollups to use. Format: type, name, metric, dimension 1, dimension 2, ..., dimension n: sum,bytes,in_bytes,dst_addr
	S3_bucket               string `yaml:"s3_bucket"`               // AWS S3 Bucket to write flows to
	S3_flush_sec            string `yaml:"s3_flush_sec"`            // Create a new output file every this many seconds
	S3_prefix               string `yaml:"s3_prefix"`               // AWS S3 Object prefix
	Sample_rate             string `yaml:"sample_rate"`             // Sampling rate to use. 1 -> 1:1 sampling, 2 -> 1:2 sampling and so on.
	Service_name            string `yaml:"service_name"`            // Service identifier
	Sinks                   string `yaml:"sinks"`                   // List of sinks to send data to. Options: (kafka|stdout|new_relic|kentik|net|http|splunk|prometheus|file|s3|gcloud)
	Snmp                    string `yaml:"snmp"`                    // yaml file containing snmp config to use
	Snmp_discovery          string `yaml:"snmp_discovery"`          // If true, try to discover snmp devices on this network as configured.
	Snmp_discovery_min      string `yaml:"snmp_discovery_min"`      // If set, run snmp discovery on this interval (in minutes).
	Snmp_discovery_on_start string `yaml:"snmp_discovery_on_start"` // If set, run snmp discovery on application start.
	Snmp_do_walk            string `yaml:"snmp_do_walk"`            // If set, try to perform a snmp walk against the targeted device.
	Snmp_dump_mibs          string `yaml:"snmp_dump_mibs"`          // If true, dump the list of possible mibs on start.
	Snmp_json2yaml          string `yaml:"snmp_json2yaml"`          // If set, convert the passed in json file to a yaml profile.
	Snmp_out_file           string `yaml:"snmp_out_file"`           // If set, write updated snmp file here.
	Snmp_poll_now           string `yaml:"snmp_poll_now"`           // If set, run one snmp poll for the specified device and then exit.
	Snmp_validate           string `yaml:"snmp_validate"`           // If true, validate mib profiles and exit.
	Snmp_walk_format        string `yaml:"snmp_walk_format"`        // use this format for walked values if -snmp_do_walk is set.
	Snmp_walk_oid           string `yaml:"snmp_walk_oid"`           // Walk this oid if -snmp_do_walk is set.
	Sqs_name                string `yaml:"sqs_name"`                // Listen for events from this queue for new objects to look at.
	Ssl_cert_file           string `yaml:"ssl_cert_file"`           // SSL Cert file to use for serving HTTPS traffic
	Ssl_key_file            string `yaml:"ssl_key_file"`            // SSL Key file to use for serving HTTPS traffic
	Stdout                  string `yaml:"stdout"`                  // Log to stdout
	SyslogFormat            string `yaml:"syslog.format"`           // Format to parse syslog messages with. Options are: Automatic|RFC3164|RFC5424|RFC6587.
	SyslogSource            string `yaml:"syslog.source"`           // Run Syslog Server at this IP:Port or unix socket.
	SyslogTcp               string `yaml:"syslog.tcp"`              // Listen on TCP for syslog messages.
	SyslogThreads           string `yaml:"syslog.threads"`          // Number of threads to use to process messages.
	SyslogUdp               string `yaml:"syslog.udp"`              // Listen on UDP for syslog messages.
	SyslogUnix              string `yaml:"syslog.unix"`             // Listen on a Unix socket for syslog messages.
	Tag_map                 string `yaml:"tag_map"`                 // CSV file mapping tag ids to strings
	Tag_map_type            string `yaml:"tag_map_type"`            // type of mapping to use for tag values. file|null
	Tee_logs                string `yaml:"tee_logs"`                // Tee log messages to sink
	Threads                 string `yaml:"threads"`                 // Number of threads to run for processing
	Udrs                    string `yaml:"udrs"`                    // UDR mapping file
	Vpc                     string `yaml:"vpc"`                     // Run VPC Flow Ingest
}

// Loads config and uses this to override any flags.
func ParseConfig(cfg KTConf) error {

	if cfg.Api_device_file != "" {
		flag.Set("api_device_file", cfg.Api_device_file)
	}
	if cfg.Api_devices != "" {
		flag.Set("api_devices", cfg.Api_devices)
	}
	if cfg.Api_root != "" {
		flag.Set("api_root", cfg.Api_root)
	}
	if cfg.Application_map != "" {
		flag.Set("application_map", cfg.Application_map)
	}
	if cfg.Asn != "" {
		flag.Set("asn", cfg.Asn)
	}
	if cfg.Aws_lambda != "" {
		flag.Set("aws_lambda", cfg.Aws_lambda)
	}
	if cfg.Aws_local_file != "" {
		flag.Set("aws_local_file", cfg.Aws_local_file)
	}
	if cfg.Aws_regions != "" {
		flag.Set("aws_regions", cfg.Aws_regions)
	}
	if cfg.BootstrapServers != "" {
		flag.Set("bootstrap.servers", cfg.BootstrapServers)
	}
	if cfg.Compression != "" {
		flag.Set("compression", cfg.Compression)
	}
	if cfg.Dns != "" {
		flag.Set("dns", cfg.Dns)
	}
	if cfg.Enricher != "" {
		flag.Set("enricher", cfg.Enricher)
	}
	if cfg.File_flush_sec != "" {
		flag.Set("file_flush_sec", cfg.File_flush_sec)
	}
	if cfg.File_on != "" {
		flag.Set("file_on", cfg.File_on)
	}
	if cfg.File_out != "" {
		flag.Set("file_out", cfg.File_out)
	}
	if cfg.Filters != "" {
		flag.Set("filters", cfg.Filters)
	}
	if cfg.Flow_only != "" {
		flag.Set("flow_only", cfg.Flow_only)
	}
	if cfg.Format != "" {
		flag.Set("format", cfg.Format)
	}
	if cfg.Format_rollup != "" {
		flag.Set("format_rollup", cfg.Format_rollup)
	}
	if cfg.Gcloud_bucket != "" {
		flag.Set("gcloud_bucket", cfg.Gcloud_bucket)
	}
	if cfg.Gcloud_content_type != "" {
		flag.Set("gcloud_content_type", cfg.Gcloud_content_type)
	}
	if cfg.Gcloud_flush_sec != "" {
		flag.Set("gcloud_flush_sec", cfg.Gcloud_flush_sec)
	}
	if cfg.Gcloud_prefix != "" {
		flag.Set("gcloud_prefix", cfg.Gcloud_prefix)
	}
	if cfg.GcpProject != "" {
		flag.Set("gcp.project", cfg.GcpProject)
	}
	if cfg.GcpSample != "" {
		flag.Set("gcp.sample", cfg.GcpSample)
	}
	if cfg.GcpSub != "" {
		flag.Set("gcp.sub", cfg.GcpSub)
	}
	if cfg.Gcp_pubsub_project_id != "" {
		flag.Set("gcp_pubsub_project_id", cfg.Gcp_pubsub_project_id)
	}
	if cfg.Gcp_pubsub_topic != "" {
		flag.Set("gcp_pubsub_topic", cfg.Gcp_pubsub_topic)
	}
	if cfg.Geo != "" {
		flag.Set("geo", cfg.Geo)
	}
	if cfg.HttpSource != "" {
		flag.Set("http.source", cfg.HttpSource)
	}
	if cfg.Http_header != "" {
		flag.Set("http_header", cfg.Http_header)
	}
	if cfg.Http_insecure != "" {
		flag.Set("http_insecure", cfg.Http_insecure)
	}
	if cfg.Http_timeout_sec != "" {
		flag.Set("http_timeout_sec", cfg.Http_timeout_sec)
	}
	if cfg.Http_url != "" {
		flag.Set("http_url", cfg.Http_url)
	}
	if cfg.Iam_role != "" {
		flag.Set("iam_role", cfg.Iam_role)
	}
	if cfg.Info_collector != "" {
		flag.Set("info_collector", cfg.Info_collector)
	}
	if cfg.Input_threads != "" {
		flag.Set("input_threads", cfg.Input_threads)
	}
	if cfg.Kafka_topic != "" {
		flag.Set("kafka_topic", cfg.Kafka_topic)
	}
	if cfg.Kentik_email != "" {
		flag.Set("kentik_email", cfg.Kentik_email)
	}
	if cfg.Kentik_plan != "" {
		flag.Set("kentik_plan", cfg.Kentik_plan)
	}
	if cfg.Kentik_relay_url != "" {
		flag.Set("kentik_relay_url", cfg.Kentik_relay_url)
	}
	if cfg.Listen != "" {
		flag.Set("listen", cfg.Listen)
	}
	if cfg.Log_level != "" {
		flag.Set("log_level", cfg.Log_level)
	}
	if cfg.Mapping != "" {
		flag.Set("mapping", cfg.Mapping)
	}
	if cfg.Max_before_sample != "" {
		flag.Set("max_before_sample", cfg.Max_before_sample)
	}
	if cfg.Max_flows_per_message != "" {
		flag.Set("max_flows_per_message", cfg.Max_flows_per_message)
	}
	if cfg.Max_threads != "" {
		flag.Set("max_threads", cfg.Max_threads)
	}
	if cfg.Metalisten != "" {
		flag.Set("metalisten", cfg.Metalisten)
	}
	if cfg.Metrics != "" {
		flag.Set("metrics", cfg.Metrics)
	}
	if cfg.Net_protocol != "" {
		flag.Set("net_protocol", cfg.Net_protocol)
	}
	if cfg.Net_server != "" {
		flag.Set("net_server", cfg.Net_server)
	}
	if cfg.Netflow_version != "" {
		flag.Set("netflow_version", cfg.Netflow_version)
	}
	if cfg.NfAddr != "" {
		flag.Set("nf.addr", cfg.NfAddr)
	}
	if cfg.NfMapping != "" {
		flag.Set("nf.mapping", cfg.NfMapping)
	}
	if cfg.NfMessageFields != "" {
		flag.Set("nf.message.fields", cfg.NfMessageFields)
	}
	if cfg.NfPort != "" {
		flag.Set("nf.port", cfg.NfPort)
	}
	if cfg.NfPromListen != "" {
		flag.Set("nf.prom.listen", cfg.NfPromListen)
	}
	if cfg.NfReuserport != "" {
		flag.Set("nf.reuserport", cfg.NfReuserport)
	}
	if cfg.NfSource != "" {
		flag.Set("nf.source", cfg.NfSource)
	}
	if cfg.NfWorkers != "" {
		flag.Set("nf.workers", cfg.NfWorkers)
	}
	if cfg.Nr_account_id != "" {
		flag.Set("nr_account_id", cfg.Nr_account_id)
	}
	if cfg.Nr_check_json != "" {
		flag.Set("nr_check_json", cfg.Nr_check_json)
	}
	if cfg.Nr_estimate_only != "" {
		flag.Set("nr_estimate_only", cfg.Nr_estimate_only)
	}
	if cfg.Nr_region != "" {
		flag.Set("nr_region", cfg.Nr_region)
	}
	if cfg.Olly_dataset != "" {
		flag.Set("olly_dataset", cfg.Olly_dataset)
	}
	if cfg.Olly_write_key != "" {
		flag.Set("olly_write_key", cfg.Olly_write_key)
	}
	if cfg.Prom_listen != "" {
		flag.Set("prom_listen", cfg.Prom_listen)
	}
	if cfg.Prom_seen != "" {
		flag.Set("prom_seen", cfg.Prom_seen)
	}
	if cfg.Rollup_and_alpha != "" {
		flag.Set("rollup_and_alpha", cfg.Rollup_and_alpha)
	}
	if cfg.Rollup_interval != "" {
		flag.Set("rollup_interval", cfg.Rollup_interval)
	}
	if cfg.Rollup_key_join != "" {
		flag.Set("rollup_key_join", cfg.Rollup_key_join)
	}
	if cfg.Rollup_top_k != "" {
		flag.Set("rollup_top_k", cfg.Rollup_top_k)
	}
	if cfg.Rollups != "" {
		flag.Set("rollups", cfg.Rollups)
	}
	if cfg.S3_bucket != "" {
		flag.Set("s3_bucket", cfg.S3_bucket)
	}
	if cfg.S3_flush_sec != "" {
		flag.Set("s3_flush_sec", cfg.S3_flush_sec)
	}
	if cfg.S3_prefix != "" {
		flag.Set("s3_prefix", cfg.S3_prefix)
	}
	if cfg.Sample_rate != "" {
		flag.Set("sample_rate", cfg.Sample_rate)
	}
	if cfg.Service_name != "" {
		flag.Set("service_name", cfg.Service_name)
	}
	if cfg.Sinks != "" {
		flag.Set("sinks", cfg.Sinks)
	}
	if cfg.Snmp != "" {
		flag.Set("snmp", cfg.Snmp)
	}
	if cfg.Snmp_discovery != "" {
		flag.Set("snmp_discovery", cfg.Snmp_discovery)
	}
	if cfg.Snmp_discovery_min != "" {
		flag.Set("snmp_discovery_min", cfg.Snmp_discovery_min)
	}
	if cfg.Snmp_discovery_on_start != "" {
		flag.Set("snmp_discovery_on_start", cfg.Snmp_discovery_on_start)
	}
	if cfg.Snmp_do_walk != "" {
		flag.Set("snmp_do_walk", cfg.Snmp_do_walk)
	}
	if cfg.Snmp_dump_mibs != "" {
		flag.Set("snmp_dump_mibs", cfg.Snmp_dump_mibs)
	}
	if cfg.Snmp_json2yaml != "" {
		flag.Set("snmp_json2yaml", cfg.Snmp_json2yaml)
	}
	if cfg.Snmp_out_file != "" {
		flag.Set("snmp_out_file", cfg.Snmp_out_file)
	}
	if cfg.Snmp_poll_now != "" {
		flag.Set("snmp_poll_now", cfg.Snmp_poll_now)
	}
	if cfg.Snmp_validate != "" {
		flag.Set("snmp_validate", cfg.Snmp_validate)
	}
	if cfg.Snmp_walk_format != "" {
		flag.Set("snmp_walk_format", cfg.Snmp_walk_format)
	}
	if cfg.Snmp_walk_oid != "" {
		flag.Set("snmp_walk_oid", cfg.Snmp_walk_oid)
	}
	if cfg.Sqs_name != "" {
		flag.Set("sqs_name", cfg.Sqs_name)
	}
	if cfg.Ssl_cert_file != "" {
		flag.Set("ssl_cert_file", cfg.Ssl_cert_file)
	}
	if cfg.Ssl_key_file != "" {
		flag.Set("ssl_key_file", cfg.Ssl_key_file)
	}
	if cfg.Stdout != "" {
		flag.Set("stdout", cfg.Stdout)
	}
	if cfg.SyslogFormat != "" {
		flag.Set("syslog.format", cfg.SyslogFormat)
	}
	if cfg.SyslogSource != "" {
		flag.Set("syslog.source", cfg.SyslogSource)
	}
	if cfg.SyslogTcp != "" {
		flag.Set("syslog.tcp", cfg.SyslogTcp)
	}
	if cfg.SyslogThreads != "" {
		flag.Set("syslog.threads", cfg.SyslogThreads)
	}
	if cfg.SyslogUdp != "" {
		flag.Set("syslog.udp", cfg.SyslogUdp)
	}
	if cfg.SyslogUnix != "" {
		flag.Set("syslog.unix", cfg.SyslogUnix)
	}
	if cfg.Tag_map != "" {
		flag.Set("tag_map", cfg.Tag_map)
	}
	if cfg.Tag_map_type != "" {
		flag.Set("tag_map_type", cfg.Tag_map_type)
	}
	if cfg.Tee_logs != "" {
		flag.Set("tee_logs", cfg.Tee_logs)
	}
	if cfg.Threads != "" {
		flag.Set("threads", cfg.Threads)
	}
	if cfg.Udrs != "" {
		flag.Set("udrs", cfg.Udrs)
	}
	if cfg.Vpc != "" {
		flag.Set("vpc", cfg.Vpc)
	}

	return nil
}
